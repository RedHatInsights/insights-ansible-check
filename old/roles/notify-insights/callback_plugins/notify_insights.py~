# -*- coding: utf-8 -*-
# adapted from the Foreman plugin
# (c) 2017 Ansible Project
# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)

from __future__ import (absolute_import, division, print_function)
__metaclass__ = type

DOCUMENTATION = '''
    callback: notify_insights
    type: notification
    short_description: Sends events to Insights
    description:
      - This callback will task events to Insights
    requirements:
'''

from datetime import datetime
from collections import defaultdict
import json
import time

from ansible.plugins.callback import CallbackBase

class CallbackModule(CallbackBase):
    """
    """

    CALLBACK_VERSION = 2.0
    CALLBACK_TYPE = 'notification'
    CALLBACK_NAME = 'notify_insights'
    CALLBACK_NEEDS_WHITELIST = False

    TIME_FORMAT = "%Y-%m-%d %H:%M:%S %f"

    def __init__(self):
        super(CallbackModule, self).__init__()
        self.items = defaultdict(list)
        self.insights_system_ids = defaultdict(list)
        self.start_time = int(time.time())

    def _build_log(self, data):
        logs = []
        for event_name, task_title, result in data:
            result["_insights_event_name"] = event_name
            result["_insights_task_title"] = task_title
            logs.append(result)
        return logs

    def _save_report(self,report):
        if "insights_system_id" in report:
            filename = "report_%s_ID_%s.txt" % (report["host"], report["insights_system_id"])
        else:
            filename = "report_%s.txt" % report["host"]
        with open(filename, 'w') as the_file:
            the_file.write(json.dumps(report))
            self._display.display("Insights report written to %s" % filename)

    def send_reports(self, stats):
        """
        """
        status = defaultdict(lambda: 0)
        metrics = {}

        for host in stats.processed.keys():
            sum = stats.summarize(host)
            status["applied"] = sum['changed']
            status["failed"] = sum['failures'] + sum['unreachable']
            status["skipped"] = sum['skipped']
            log = self._build_log(self.items[host])
            metrics["time"] = {"total": int(time.time()) - self.start_time}
            now = datetime.now().strftime(self.TIME_FORMAT)
            report = {
                "host": host,
                "reported_at": now,
                "metrics": metrics,
                "status": status,
                "task_results": log,
            }
            if host in self.insights_system_ids:
                report["insights_system_id"] = self.insights_system_ids[host]
            self._save_report(report)
            self.items[host] = []

    def append_result(self, result, event_name):
        task_name = result._task.get_name()
        host_name = result._host.get_name()
        if "ansible_facts" in result._result:
            if "ansible_local" in result._result["ansible_facts"]:
                if "insights" in result._result["ansible_facts"]["ansible_local"]:
                    if "system_id" in result._result["ansible_facts"]["ansible_local"]["insights"]:
                        self.insights_system_ids[host_name] = result._result["ansible_facts"]["ansible_local"]["insights"]["system_id"]
        self.items[host_name].append((event_name, task_name, result._result))


    # Ansible Callback API
    #
    #
    #

    def v2_runner_on_failed(self, result, ignore_errors=False):
        self.append_result(result, "failed")

    def v2_runner_on_ok(self, result):
        self.append_result(result, "ok")

    def v2_runner_on_skipped(self, result):
        self.append_result(result, "skipped")

    def v2_runner_on_unreachable(self, result):
        self.append_result(result, "unreachable")

    def v2_playbook_on_stats(self, stats):
        self.send_reports(stats)
